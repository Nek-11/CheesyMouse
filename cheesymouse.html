<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CheesyMouse - Wine Cellar Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(45deg, #1a0f0a, #2d1b14);
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            background: #0d0805;
            border: 6px solid #8B4513;
            border-radius: 8px;
            overflow: hidden;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            box-shadow: 
                0 0 30px rgba(139, 69, 19, 0.5),
                inset 0 0 20px rgba(0, 0, 0, 0.8);
        }
        
        #gameCanvas {
            display: block;
            background: transparent;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
        }
        
        #score {
            font-size: 24px;
            color: #FFD700;
            text-shadow: 
                2px 2px 0px #8B4513,
                4px 4px 8px rgba(0, 0, 0, 0.8);
            margin-bottom: 10px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #8B4513;
            border-radius: 4px;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2d1b14, #1a0f0a);
            color: #FFD700;
            padding: 40px;
            border: 6px solid #8B4513;
            border-radius: 12px;
            text-align: center;
            display: none;
            z-index: 200;
            box-shadow: 
                0 0 40px rgba(0, 0, 0, 0.9),
                inset 0 0 20px rgba(139, 69, 19, 0.3);
        }
        
        #gameOver h2 {
            margin: 0 0 20px 0;
            font-size: 20px;
            text-shadow: 2px 2px 0px #8B4513;
            color: #FF6B35;
        }
        
        #gameOver p {
            margin: 15px 0;
            font-size: 14px;
            text-shadow: 1px 1px 0px #8B4513;
        }
        
        #restartBtn {
            background: linear-gradient(135deg, #FF6B35, #E55A2B);
            color: #fff;
            border: 4px solid #8B4513;
            border-radius: 8px;
            padding: 16px 28px;
            font-size: 14px;
            font-family: 'Press Start 2P', monospace;
            cursor: pointer;
            margin-top: 20px;
            text-shadow: 1px 1px 0px #8B4513;
            box-shadow: 
                0 4px 0 #8B4513,
                0 6px 12px rgba(0, 0, 0, 0.6);
            transition: all 0.1s ease;
        }
        
        #restartBtn:hover {
            background: linear-gradient(135deg, #E55A2B, #D44920);
            transform: translateY(2px);
            box-shadow: 
                0 2px 0 #8B4513,
                0 4px 8px rgba(0, 0, 0, 0.6);
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 12px;
            text-align: center;
            text-shadow: 2px 2px 0px #8B4513;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border: 2px solid #8B4513;
            border-radius: 4px;
        }
        
        #titleScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2d1b14, #1a0f0a);
            color: #FFD700;
            padding: 60px;
            border: 8px solid #8B4513;
            border-radius: 16px;
            text-align: center;
            z-index: 300;
            box-shadow: 
                0 0 50px rgba(0, 0, 0, 0.9),
                inset 0 0 30px rgba(139, 69, 19, 0.3);
        }
        
        #titleScreen h1 {
            font-size: 32px;
            margin-bottom: 30px;
            text-shadow: 3px 3px 0px #8B4513;
            color: #FF6B35;
        }
        
        #titleScreen p {
            font-size: 14px;
            margin-bottom: 40px;
            text-shadow: 1px 1px 0px #8B4513;
        }
        
        #startBtn {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #8B4513;
            border: 4px solid #8B4513;
            border-radius: 8px;
            padding: 20px 32px;
            font-size: 16px;
            font-family: 'Press Start 2P', monospace;
            cursor: pointer;
            text-shadow: none;
            box-shadow: 
                0 4px 0 #8B4513,
                0 8px 16px rgba(0, 0, 0, 0.6);
            transition: all 0.1s ease;
        }
        
        #startBtn:hover {
            background: linear-gradient(135deg, #FFA500, #FF8C00);
            transform: translateY(2px);
            box-shadow: 
                0 2px 0 #8B4513,
                0 6px 12px rgba(0, 0, 0, 0.6);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="titleScreen">
            <h1>CHEESYMOUSE</h1>
            <p>Navigate through the wine cellar!<br>Collect cheese, avoid the bottles!</p>
            <button id="startBtn">START GAME</button>
        </div>
        
        <div id="ui">
            <div id="score">0</div>
        </div>
        
        <div id="gameOver">
            <h2>GAME OVER!</h2>
            <p>The mouse got caught!</p>
            <p id="finalScore">CHEESE COLLECTED: 0</p>
            <button id="restartBtn">TRY AGAIN</button>
        </div>
        
        <div id="instructions">
            PRESS SPACEBAR TO JUMP
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const gameOverElement = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        const titleScreen = document.getElementById('titleScreen');
        const startBtn = document.getElementById('startBtn');

        // Disable anti-aliasing for pixelated look
        ctx.imageSmoothingEnabled = false;

        // High Score System
        let highScore = 0;

        // Simple GIF frame loader - manually extract frames
        class GIFPlayer {
            constructor(basePath, frameCount) {
                this.basePath = basePath;
                this.frameCount = frameCount;
                this.frames = [];
                this.currentFrame = 0;
                this.frameRate = 10; // frames per second
                this.lastFrameTime = 0;
                this.isLoaded = false;
                this.isPlaying = false;
                this.loop = true;
            }

            async loadFrames() {
                const loadPromises = [];
                for (let i = 0; i < this.frameCount; i++) {
                    const img = new Image();
                    const promise = new Promise((resolve, reject) => {
                        img.onload = () => resolve(img);
                        img.onerror = () => {
                            console.log(`Frame ${i} failed to load, creating fallback`);
                            // Create fallback frame
                            const canvas = document.createElement('canvas');
                            canvas.width = 64;
                            canvas.height = 32;
                            const ctx = canvas.getContext('2d');
                            ctx.fillStyle = '#8B7355';
                            ctx.fillRect(0, 0, 64, 32);
                            resolve(canvas);
                        };
                    });
                    
                    // Try different frame naming conventions
                    img.src = `${this.basePath}_frame_${i.toString().padStart(3, '0')}.png`;
                    loadPromises.push(promise);
                }

                try {
                    this.frames = await Promise.all(loadPromises);
                    this.isLoaded = true;
                    console.log(`GIF loaded: ${this.frames.length} frames`);
                } catch (error) {
                    console.log('GIF frames failed to load, using single image');
                    // Fallback to single image
                    const img = new Image();
                    img.onload = () => {
                        this.frames = [img];
                        this.frameCount = 1;
                        this.isLoaded = true;
                    };
                    img.onerror = () => {
                        // Ultimate fallback - create a simple canvas frame
                        const canvas = document.createElement('canvas');
                        canvas.width = 64;
                        canvas.height = 32;
                        const ctx = canvas.getContext('2d');
                        this.drawFallbackMouse(ctx, 32, 16);
                        this.frames = [canvas];
                        this.frameCount = 1;
                        this.isLoaded = true;
                    };
                    img.src = this.basePath + '.png';
                }
            }

            drawFallbackMouse(ctx, x, y) {
                ctx.save();
                ctx.translate(x, y);
                
                // Mouse body (wider, horizontal)
                ctx.fillStyle = '#8B7355';
                ctx.beginPath();
                ctx.ellipse(0, 0, 20, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Mouse head (wider and more prominent)
                ctx.fillStyle = '#9B8365';
                ctx.beginPath();
                ctx.ellipse(-12, -2, 14, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Ears
                ctx.fillStyle = '#8B7355';
                ctx.beginPath();
                ctx.arc(-18, -8, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(-10, -7, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes (positioned for wider face)
                ctx.fillStyle = '#000';
                ctx.fillRect(-20, -4, 2, 2);
                ctx.fillRect(-8, -4, 2, 2);
                
                // Nose
                ctx.fillStyle = '#D2691E';
                ctx.fillRect(-22, -1, 2, 2);
                
                // Tail (longer and more curved)
                ctx.strokeStyle = '#8B7355';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(18, 2);
                ctx.bezierCurveTo(25, 0, 32, -4, 38, -8);
                ctx.stroke();
                
                ctx.restore();
            }

            play() {
                this.isPlaying = true;
                this.currentFrame = 0;
            }

            pause() {
                this.isPlaying = false;
            }

            reset() {
                this.currentFrame = 0;
            }

            update() {
                if (!this.isPlaying || !this.isLoaded || this.frameCount <= 1) return;
                
                const now = Date.now();
                const frameInterval = 1000 / this.frameRate;
                
                if (now - this.lastFrameTime >= frameInterval) {
                    this.currentFrame++;
                    if (this.currentFrame >= this.frameCount) {
                        if (this.loop) {
                            this.currentFrame = 0;
                        } else {
                            this.currentFrame = this.frameCount - 1;
                            this.isPlaying = false;
                        }
                    }
                    this.lastFrameTime = now;
                }
            }

            getCurrentFrame() {
                if (!this.isLoaded || this.frames.length === 0) return null;
                return this.frames[Math.min(this.currentFrame, this.frames.length - 1)];
            }
        }

        // --- Asset Loading ---
        let assetsLoaded = 0;
        const totalAssets = 8; // 5 images + 3 GIF players

        function assetLoaded() {
            assetsLoaded++;
            console.log(`Asset loaded: ${assetsLoaded}/${totalAssets}`);
            if (assetsLoaded === totalAssets) {
                console.log('All assets loaded and ready!');
                gameLoop();
            }
        }

        // Load static images
        let backgroundImg = new Image();
        backgroundImg.onload = assetLoaded;
        backgroundImg.onerror = assetLoaded;
        backgroundImg.src = 'images/background.png';

        let shelfTopImg = new Image();
        shelfTopImg.onload = assetLoaded;
        shelfTopImg.onerror = assetLoaded;
        shelfTopImg.src = 'images/bottle_top.png';

        let shelfDownImg = new Image();
        shelfDownImg.onload = assetLoaded;
        shelfDownImg.onerror = assetLoaded;
        shelfDownImg.src = 'images/bottle_down.png';

        let cheeseImg = new Image();
        cheeseImg.onload = assetLoaded;
        cheeseImg.onerror = assetLoaded;
        cheeseImg.src = 'images/cheese.png';

        let bricksImg = new Image();
        bricksImg.onload = assetLoaded;
        bricksImg.onerror = assetLoaded;
        bricksImg.src = 'images/bricks.png';
        
        // Load GIF animations using our custom player
        const mouseGifPlayer = new GIFPlayer('images/mouse', 6); // Corrected: 6 frames (000-005)
        const mouseEatsGifPlayer = new GIFPlayer('images/mouse-eats', 5); // Corrected: 5 frames (000-004)
        const mouseDeadGifPlayer = new GIFPlayer('images/mouse-dead', 6); // Death animation: 6 frames (0-5)

        // Load GIF frames asynchronously
        mouseGifPlayer.loadFrames().then(() => {
            mouseGifPlayer.play();
            assetLoaded();
        });

        mouseEatsGifPlayer.loadFrames().then(() => {
            assetLoaded();
        });

        mouseDeadGifPlayer.loadFrames().then(() => {
            mouseDeadGifPlayer.loop = false; // Don't loop the death animation
            assetLoaded();
        });

        // Mouse object
        const mouse = {
            x: 120,
            y: 300,
            width: 80,  // Made wider for better reference image match
            height: 40, // Made taller for better proportions
            velocity: 0,
            gravity: 0.42,
            jumpPower: -7.5, // Reduced from -8.5 to make game easier
            rotation: 0,
            isEating: false,
            eatTimer: 0,
            isDead: false,
            deathAnimationPlayed: false
        };

        // Game state
        let gameStarted = false;
        let gameRunning = false;
        let score = 0;
        let gameSpeed = 2.2; // Slightly faster initial speed
        let maxGameSpeed = 6.5; // Maximum speed cap
        let speedAcceleration = 0.1; // Faster acceleration
        let bottlesPassed = 0;
        let frameCount = 0;

        // Arrays for game objects
        let wineShelves = [];
        let cheeses = [];
        let particles = [];

        // Ground system for Flappy Bird style scrolling
        let groundOffset = 0;
        const groundHeight = 100;

        // Audio context for sound effects
        let audioContext;

        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(frequency, duration, type = 'square', volume = 0.1) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function drawPixelRect(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(x), Math.floor(y), width, height);
        }

        function drawPixelGradient(x, y, width, height, colorTop, colorBottom) {
            const gradient = ctx.createLinearGradient(0, y, 0, y + height);
            gradient.addColorStop(0, colorTop);
            gradient.addColorStop(1, colorBottom);
            ctx.fillStyle = gradient;
            ctx.fillRect(Math.floor(x), Math.floor(y), width, height);
        }

        // Enhanced fallback mouse drawing
        function drawFallbackMouse() {
            const x = Math.floor(mouse.x);
            const y = Math.floor(mouse.y);
            
            ctx.save();
            ctx.translate(x + mouse.width/2, y + mouse.height/2);
            ctx.rotate(mouse.rotation);
            
            // Mouse body (wider, more horizontal oval like reference)
            ctx.fillStyle = '#8B7355';
            ctx.beginPath();
            ctx.ellipse(0, 0, mouse.width/2.2, mouse.height/2.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Mouse head (wider and more prominent)
            ctx.fillStyle = '#9B8365';
            ctx.beginPath();
            ctx.ellipse(-mouse.width/3.5, -mouse.height/8, mouse.width/2.8, mouse.height/2.2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Ears (positioned for wider head)
            ctx.fillStyle = '#8B7355';
            ctx.beginPath();
            ctx.arc(-mouse.width/2.5, -mouse.height/2, mouse.width/10, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-mouse.width/4.5, -mouse.height/1.8, mouse.width/12, 0, Math.PI * 2);
            ctx.fill();

            // Inner ears (pink)
            ctx.fillStyle = '#D2691E';
            ctx.beginPath();
            ctx.arc(-mouse.width/2.5, -mouse.height/2, mouse.width/18, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-mouse.width/4.5, -mouse.height/1.8, mouse.width/20, 0, Math.PI * 2);
            ctx.fill();

            // Eyes (positioned for wider face)
            ctx.fillStyle = '#000';
            ctx.fillRect(-mouse.width/2.2, -mouse.height/5, 4, 4);
            ctx.fillRect(-mouse.width/6, -mouse.height/5, 4, 4);

            // Nose (centered on wider snout)
            ctx.fillStyle = '#D2691E';
            ctx.fillRect(-mouse.width/1.8, -mouse.height/12, 4, 4);

            // Tail (longer and more curved for wider mouse)
            const tailWag = Math.sin(frameCount * 0.15) * 0.3;
            ctx.strokeStyle = '#8B7355';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(mouse.width/2.2, mouse.height/6);
            ctx.bezierCurveTo(
                mouse.width/1.3 + tailWag * 12, mouse.height/3 + tailWag * 6,
                mouse.width/1.1 + tailWag * 18, -mouse.height/6 + tailWag * 10,
                mouse.width/0.7 + tailWag * 25, -mouse.height/3 + tailWag * 12
            );
            ctx.stroke();
            
            ctx.restore();
        }

        function drawMouse() {
            // Update GIF players
            mouseGifPlayer.update();
            mouseEatsGifPlayer.update();
            mouseDeadGifPlayer.update();

            // Choose which GIF to display based on mouse state
            let currentPlayer;
            if (mouse.isDead) {
                currentPlayer = mouseDeadGifPlayer;
                // Start death animation if not already started
                if (!mouse.deathAnimationPlayed) {
                    mouseDeadGifPlayer.play();
                    mouse.deathAnimationPlayed = true;
                }
            } else if (mouse.isEating) {
                currentPlayer = mouseEatsGifPlayer;
            } else {
                currentPlayer = mouseGifPlayer;
            }
            
            let frame = currentPlayer.getCurrentFrame();

            if (frame && currentPlayer.isLoaded) {
                const x = Math.floor(mouse.x);
                const y = Math.floor(mouse.y);
                
                ctx.save();
                ctx.translate(x + mouse.width/2, y + mouse.height/2);
                
                // Don't rotate the mouse when dead
                if (!mouse.isDead) {
                    ctx.rotate(mouse.rotation);
                }

                // Calculate aspect ratio and size
                const aspectRatio = frame.width / frame.height;
                let drawWidth = mouse.width;
                let drawHeight = drawWidth / aspectRatio;

                if (drawHeight > mouse.height) {
                    drawHeight = mouse.height;
                    drawWidth = drawHeight * aspectRatio;
                }
                
                ctx.drawImage(frame, -drawWidth/2, -drawHeight/2, drawWidth, drawHeight);
                ctx.restore();
            } else {
                // Fallback to drawn mouse
                drawFallbackMouse();
            }
            
            if (mouse.isEating && !mouse.isDead) {
                mouse.eatTimer--;
                if(mouse.eatTimer <= 0) {
                    mouse.isEating = false;
                    mouseEatsGifPlayer.pause();
                    mouseEatsGifPlayer.reset();
                    mouseGifPlayer.play();
                }
            }
        }

        function drawStaticBackground() {
            // Use the provided background image if loaded
            if (backgroundImg.complete && backgroundImg.naturalWidth > 0) {
                // Draw a subtle colored background behind the image
                drawPixelGradient(0, 0, canvas.width, canvas.height - groundHeight, '#2a1810', '#1a100a');
                
                // Draw the background image with slight opacity so it doesn't overpower
                ctx.globalAlpha = 0.85;
                ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height - groundHeight);
                ctx.globalAlpha = 1.0;
                
                // Add a subtle overlay to maintain game atmosphere
                ctx.fillStyle = 'rgba(42, 24, 16, 0.15)';
                ctx.fillRect(0, 0, canvas.width, canvas.height - groundHeight);
            } else {
                // Fallback background while image loads
                drawPixelGradient(0, 0, canvas.width, canvas.height - groundHeight, '#2a1810', '#1a100a');
                
                // Simple stone texture fallback
                for (let y = 0; y < canvas.height - groundHeight; y += 32) {
                    for (let x = 0; x < 100; x += 16) {
                        const shade = 0.7 + ((x + y) % 5) * 0.06;
                        drawPixelRect(x, y, 16, 16, `rgba(45, 27, 20, ${shade})`);
                    }
                    for (let x = canvas.width - 100; x < canvas.width; x += 16) {
                        const shade = 0.7 + ((x + y) % 5) * 0.06;
                        drawPixelRect(x, y, 16, 16, `rgba(45, 27, 20, ${shade})`);
                    }
                }
            }
        }

        function updateWineShelves() {
            for (let i = wineShelves.length - 1; i >= 0; i--) {
                const shelf = wineShelves[i];
                shelf.x -= gameSpeed;
                
                // Check if mouse passed the shelf
                if (!shelf.passed && shelf.x + shelf.width < mouse.x) {
                    shelf.passed = true;
                    bottlesPassed++;
                    
                    // Fixed speed acceleration with cap
                    if (gameSpeed < maxGameSpeed) {
                        gameSpeed += speedAcceleration;
                        console.log('Speed increased to:', gameSpeed.toFixed(2));
                    }

                    // Passing particles
                    for (let j = 0; j < 8; j++) {
                        createParticle(
                            shelf.x + shelf.width,
                            shelf.topHeight + (shelf.bottomY - shelf.topHeight) / 2,
                            '255, 215, 0', 5, 35
                        );
                    }
                }
                
                // Precise collision with the shelf edges - using 70% of mouse area for realistic collision
                const groundY = canvas.height - groundHeight;

                // Calculate the mouse's actual collision area (70% of total size, centered)
                const mouseCollisionWidth = mouse.width * 0.7;
                const mouseCollisionHeight = mouse.height * 0.7;
                const mouseCollisionX = mouse.x + (mouse.width - mouseCollisionWidth) / 2;
                const mouseCollisionY = mouse.y + (mouse.height - mouseCollisionHeight) / 2;

                // Check collision with actual visual shelf bounds
                if ((mouseCollisionX + mouseCollisionWidth > shelf.x && mouseCollisionX < shelf.x + shelf.width) &&
                    ((mouseCollisionY < shelf.topHeight) || // Top shelf collision: from 0 to shelf.topHeight
                     (mouseCollisionY + mouseCollisionHeight > shelf.bottomY))) { // Bottom shelf collision: from shelf.bottomY to ground
                    
                    addScreenShake(12);
                    gameOver();
                    return;
                }
                
                // Remove off-screen shelves
                if (shelf.x + shelf.width < 0) {
                    wineShelves.splice(i, 1);
                }
            }
        }

        function drawMovingGround() {
            const groundY = canvas.height - groundHeight;
            
            // Update ground offset for scrolling
            if (gameRunning) {
                groundOffset = (groundOffset + gameSpeed) % 800; // Reset every 800 pixels to match your image width
            }
            
            // Use your custom bricks.png image if loaded
            if (bricksImg.complete && bricksImg.naturalWidth > 0) {
                // Draw your 800x95 bricks image, scrolling horizontally
                for (let x = -800; x < canvas.width + 800; x += 800) {
                    const drawX = x - groundOffset;
                    ctx.drawImage(bricksImg, drawX, groundY, 800, groundHeight);
                }
            } else {
                // Fallback to programmatic bricks if image fails to load
                drawPixelGradient(0, groundY, canvas.width, groundHeight, '#640000', '#3c0000');
                
                const brickHeight = 20;
                const brickWidth = 40;
                
                for (let x = -brickWidth; x < canvas.width + brickWidth; x += brickWidth) {
                    const drawX = x - groundOffset;
                    
                    // Main brick (using R:100 base color)
                    drawPixelRect(drawX, groundY, brickWidth - 2, brickHeight, '#640000');
                    
                    // Brick highlight (slightly lighter red)
                    drawPixelRect(drawX, groundY, brickWidth - 2, 3, '#7d0000');
                    
                    // Brick shadow (darker red for depth)
                    drawPixelRect(drawX, groundY + brickHeight - 3, brickWidth - 2, 3, '#4b0000');
                    drawPixelRect(drawX + brickWidth - 4, groundY + 2, 2, brickHeight - 4, '#4b0000');
                    
                    // Mortar lines (very dark red/black)
                    drawPixelRect(drawX + brickWidth - 2, groundY, 2, brickHeight, '#1e0000');
                    
                    // Optional: Add some texture variation
                    if ((drawX + Math.floor(frameCount * 0.1)) % 80 < 40) {
                        // Subtle brick texture (mid-tone red)
                        drawPixelRect(drawX + 2, groundY + 2, 2, 2, '#550000');
                        drawPixelRect(drawX + brickWidth - 8, groundY + brickHeight - 6, 2, 2, '#4b0000');
                    }
                }
                
                // Ground surface highlight (accent red line)
                drawPixelRect(0, groundY, canvas.width, 1, '#7d0000');
            }
        }

        function drawWineShelves(shelf) {
            const x = Math.floor(shelf.x);
            const shelfWidth = 90;

            if (shelfTopImg.complete && shelfDownImg.complete && shelfTopImg.naturalWidth > 0 && shelfDownImg.naturalWidth > 0) {
                // Calculate proper scale to fit game proportions
                const gameWidth = shelfWidth; // Target width for bottles in game
                const topScaleX = gameWidth / shelfTopImg.naturalWidth;
                const bottomScaleX = gameWidth / shelfDownImg.naturalWidth;
                
                // Scaled image heights (maintaining aspect ratio)
                const scaledTopHeight = shelfTopImg.naturalHeight * topScaleX;
                const scaledBottomHeight = shelfDownImg.naturalHeight * bottomScaleX;

                // Top Shelf
                if (shelf.topHeight > 0) {
                    if (shelf.topHeight >= scaledTopHeight) {
                        // STRETCH - game height is bigger than image, stretch it
                        ctx.drawImage(shelfTopImg, x, 0, gameWidth, shelf.topHeight);
                    } else {
                        // CUT - game height is smaller than image, crop from bottom of image
                        const cropRatio = shelf.topHeight / scaledTopHeight;
                        const cropHeight = shelfTopImg.naturalHeight * cropRatio;
                        const startY = shelfTopImg.naturalHeight - cropHeight; // Cut from top, show bottom
                        ctx.drawImage(
                            shelfTopImg,
                            0, startY, shelfTopImg.naturalWidth, cropHeight,
                            x, 0, gameWidth, shelf.topHeight
                        );
                    }
                }

                // Bottom Shelf
                if (shelf.bottomHeight > 0) {
                    const groundY = canvas.height - groundHeight;
                    const actualBottomHeight = groundY - shelf.bottomY;
                    if (actualBottomHeight >= scaledBottomHeight) {
                        // STRETCH - game height is bigger than image, stretch it
                        ctx.drawImage(shelfDownImg, x, shelf.bottomY, gameWidth, actualBottomHeight);
                    } else {
                        // CUT - game height is smaller than image, crop from top of image
                        const cropRatio = actualBottomHeight / scaledBottomHeight;
                        const cropHeight = shelfDownImg.naturalHeight * cropRatio;
                        ctx.drawImage(
                            shelfDownImg,
                            0, 0, shelfDownImg.naturalWidth, cropHeight, // Cut from top, show top
                            x, shelf.bottomY, gameWidth, actualBottomHeight
                        );
                    }
                }
            } else {
                // Fallback drawing
                if (shelf.topHeight > 0) {
                    drawPixelGradient(x, shelf.topHeight - 20, shelfWidth, 20, '#8B4513', '#654321');
                }
                if (shelf.bottomHeight > 0) {
                    drawPixelGradient(x, shelf.bottomY, shelfWidth, 20, '#8B4513', '#654321');
                }
            }
        }

        function drawCheese(cheese) {
            if (!cheese.collected) {
                const x = Math.floor(cheese.x - cheese.size);
                const y = Math.floor(cheese.y - cheese.size);
                
                // Yellowish glow effect
                const glowIntensity = 0.5 + Math.sin(frameCount * 0.1) * 0.3;
                ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
                ctx.shadowBlur = 15 * glowIntensity;
                
                // Floating animation
                const float = Math.sin(frameCount * 0.08 + cheese.x * 0.01) * 3;
                
                // Use the cheese.png image if available
                if (cheeseImg.complete && cheeseImg.naturalWidth > 0) {
                    ctx.drawImage(cheeseImg, x, y + float, cheese.size * 2, cheese.size * 2);
                } else {
                    // Fallback cheese drawing
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x, y + float, cheese.size * 2, cheese.size * 2);
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(x + 2, y + float + 2, cheese.size - 2, cheese.size - 2);
                }
                
                // Reset shadow
                ctx.shadowBlur = 0;
            }
        }

        function createParticle(x, y, color, velocity, life, size = null) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * velocity,
                vy: (Math.random() - 0.5) * velocity - Math.random() * 2, // Slight upward bias
                color: color,
                life: life,
                maxLife: life,
                size: size || (Math.random() * 4 + 2),
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.2
            });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.15; // gravity
                particle.vx *= 0.98; // air resistance
                particle.rotation += particle.rotationSpeed;
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    const alpha = (particle.life / particle.maxLife) * 0.8;
                    ctx.save();
                    ctx.translate(particle.x, particle.y);
                    ctx.rotate(particle.rotation);
                    ctx.fillStyle = `rgba(${particle.color}, ${alpha})`;
                    ctx.fillRect(-particle.size/2, -particle.size/2, particle.size, particle.size);
                    ctx.restore();
                }
            }
        }

        function createWineShelf() {
            const groundY = canvas.height - groundHeight;
            
            // PROGRESSIVE DIFFICULTY: Gap gets smaller as score increases
            const baseSmallGap = 140;
            const baseLargeGap = 210;
            const minGap = 100; // Minimum gap size to keep it playable
            
            // Reduce gap size by 2 pixels every 5 points, but don't go below minimum
            const gapReduction = Math.min(Math.floor(score / 5) * 2, baseSmallGap - minGap);
            const smallGap = Math.max(baseSmallGap - gapReduction, minGap);
            const largeGap = Math.max(baseLargeGap - gapReduction, minGap + 40);
            
            const gapSize = Math.random() < 0.5 ? smallGap : largeGap;
            
            // VARIABLE GAP POSITIONING with safe margins
            const safeMargin = 50; // Safe margin from top and bottom
            const totalHeight = groundY - 80; // Total available height
            const minGapTop = safeMargin; // Minimum distance from top
            const maxGapTop = totalHeight - gapSize - safeMargin; // Maximum distance from top
            
            // Randomly position the gap vertically within safe bounds
            const gapTopPosition = minGapTop + Math.random() * (maxGapTop - minGapTop);
            
            const topShelfHeight = gapTopPosition;
            const bottomShelfStart = gapTopPosition + gapSize;
            const bottomShelfHeight = totalHeight - bottomShelfStart;
            
            console.log('Gap size:', gapSize, gapSize === smallGap ? '(SMALL)' : '(LARGE)', 
                       'Gap position:', Math.round(gapTopPosition), 'to', Math.round(bottomShelfStart),
                       'Difficulty reduction:', gapReduction);
            
            const shelf = {
                x: canvas.width,
                width: 90,
                topY: 0,
                topHeight: topShelfHeight,
                bottomY: bottomShelfStart,
                bottomHeight: bottomShelfHeight,
                passed: false
            };
            
            wineShelves.push(shelf);
            
            // Create cheese in the middle of the gap
            const cheese = {
                x: shelf.x + shelf.width / 2,
                y: gapTopPosition + gapSize / 2,
                size: 12,
                collected: false
            };
            
            cheeses.push(cheese);
        }

        function updateMouse() {
            mouse.velocity += mouse.gravity;
            mouse.y += mouse.velocity;
            
            // Smooth rotation based on velocity
            const targetRotation = Math.min(Math.max(mouse.velocity * 0.06, -0.3), 0.5);
            mouse.rotation += (targetRotation - mouse.rotation) * 0.12;
            
            // Check boundaries with ground system
            const groundY = canvas.height - groundHeight;
            if (mouse.y < -10 || mouse.y + mouse.height > groundY - 10) {
                gameOver();
            }
        }

        // Screen shake system for premium game feel
        let screenShake = 0;
        let screenShakeDecay = 0.9;

        function addScreenShake(intensity) {
            screenShake = Math.max(screenShake, intensity);
        }

        function updateScreenShake() {
            screenShake *= screenShakeDecay;
            if (screenShake < 0.1) screenShake = 0;
        }

        function applyScreenShake() {
            if (screenShake > 0) {
                const shakeX = (Math.random() - 0.5) * screenShake;
                const shakeY = (Math.random() - 0.5) * screenShake;
                ctx.translate(shakeX, shakeY);
            }
        }

        function updateCheeses() {
            for (let i = cheeses.length - 1; i >= 0; i--) {
                const cheese = cheeses[i];
                cheese.x -= gameSpeed;
                
                // Check collision with mouse - using 70% collision area for consistency
                if (!cheese.collected) {
                    // Calculate the mouse's actual collision area (70% of total size, centered)
                    const mouseCollisionWidth = mouse.width * 0.7;
                    const mouseCollisionHeight = mouse.height * 0.7;
                    const mouseCollisionX = mouse.x + (mouse.width - mouseCollisionWidth) / 2;
                    const mouseCollisionY = mouse.y + (mouse.height - mouseCollisionHeight) / 2;

                    // Check if mouse collision area overlaps with cheese
                    if (mouseCollisionX + mouseCollisionWidth > cheese.x - cheese.size &&
                        mouseCollisionX < cheese.x + cheese.size &&
                        mouseCollisionY + mouseCollisionHeight > cheese.y - cheese.size &&
                        mouseCollisionY < cheese.y + cheese.size) {
                    
                    cheese.collected = true;
                    score++;
                    scoreElement.textContent = score;
                    mouse.isEating = true;
                    mouse.eatTimer = 45;
                    
                    // Control GIF animations
                    mouseGifPlayer.pause();
                    mouseEatsGifPlayer.play();

                    // Cheese crunch particles
                    for (let j = 0; j < 10; j++) {
                        createParticle(
                            cheese.x,
                            cheese.y,
                            '255, 215, 0',
                            4,
                            20,
                            Math.random() * 3 + 1
                        );
                    }
                    
                    // Add sparkle particles
                    for (let j = 0; j < 8; j++) {
                        createParticle(
                            cheese.x,
                            cheese.y,
                            '255, 255, 255',
                            6,
                            35,
                            1
                        );
                    }
                    
                    playSound(880, 0.25, 'sine', 0.18);
                    }
                }
                
                // Remove off-screen cheese
                if (cheese.x < -cheese.size) {
                    cheeses.splice(i, 1);
                }
            }
        }

        function jump() {
            if (gameRunning) {
                mouse.velocity = mouse.jumpPower;
                
                // Enhanced jump particles with sparkle effect
                for (let i = 0; i < 8; i++) {
                    createParticle(
                        mouse.x + Math.random() * mouse.width,
                        mouse.y + mouse.height,
                        '255, 255, 255',
                        4,
                        25,
                        Math.random() * 3 + 1
                    );
                }
                
                // Add some golden sparkles
                for (let i = 0; i < 3; i++) {
                    createParticle(
                        mouse.x + mouse.width/2,
                        mouse.y + mouse.height/2,
                        '255, 215, 0',
                        2,
                        30,
                        2
                    );
                }
                
                playSound(520, 0.15, 'square', 0.12);
            }
        }

        function gameOver() {
            gameRunning = false;
            
            // Trigger death animation
            mouse.isDead = true;
            mouse.deathAnimationPlayed = false;
            
            // Update high score
            if (score > highScore) {
                highScore = score;
            }
            
            finalScoreElement.innerHTML = `CHEESE COLLECTED: ${score}<br>HIGH SCORE: ${highScore}`;
            gameOverElement.style.display = 'block';
            
            // Game over sound sequence
            setTimeout(() => playSound(200, 0.3, 'sawtooth', 0.15), 0);
            setTimeout(() => playSound(150, 0.4, 'sawtooth', 0.12), 200);
            setTimeout(() => playSound(100, 0.5, 'sawtooth', 0.1), 500);
        }

        function startGame() {
            gameStarted = true;
            gameRunning = true;
            titleScreen.style.display = 'none';
            score = 0;
            gameSpeed = 2.2; // Reset to initial faster speed
            bottlesPassed = 0;
            frameCount = 0;
            mouse.x = 120;
            mouse.y = 300;
            mouse.velocity = 0;
            mouse.rotation = 0;
            mouse.isEating = false;
            mouse.eatTimer = 0;
            mouse.isDead = false;
            mouse.deathAnimationPlayed = false;
            wineShelves = [];
            cheeses = [];
            particles = [];
            scoreElement.textContent = '0';
            gameOverElement.style.display = 'none';
            
            // Reset GIF animations
            mouseGifPlayer.play();
            mouseEatsGifPlayer.pause();
            mouseEatsGifPlayer.reset();
            mouseDeadGifPlayer.pause();
            mouseDeadGifPlayer.reset();
            
            createWineShelf();
        }

        function restart() {
            startGame();
        }

        function gameLoop() {
            frameCount++;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply screen shake for premium game feel
            ctx.save();
            applyScreenShake();
            
            // Draw background and shelves FIRST
            drawStaticBackground();
            wineShelves.forEach(drawWineShelves);
            
            if (gameRunning) {
                updateMouse();
                updateWineShelves(); 
                updateCheeses();
                
                // Create new wine shelves
                if (wineShelves.length === 0 || wineShelves[wineShelves.length - 1].x < canvas.width - 320) {
                    createWineShelf(); 
                }
            } else if (!gameStarted) {
                // Draw a placeholder for the mouse on the title screen
                drawMouse();
            }
            
            // Draw CHEESE, then GROUND, then MOUSE for correct layering
            cheeses.forEach(drawCheese);
            drawMovingGround();
            if (gameRunning || gameStarted) {
            drawMouse();
            }

            updateParticles();
            
            // Update screen shake
            updateScreenShake();
            
            ctx.restore();
            
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (!audioContext) {
                    initAudio();
                }
                if (!gameStarted) {
                    startGame();
                } else {
                jump();
                }
            }
        });

        startBtn.addEventListener('click', () => {
            if (!audioContext) {
                initAudio();
            }
            startGame();
        });

        restartBtn.addEventListener('click', restart);
    </script>
</body>
</html>